#!/usr/bin/env node
// -*- mode: javascript -*-
/*
  how to use it
  git-your-emacs command arg0 arg1 ...
  git-your-emacs update -- update all 
 */
var fs = require("fs");
var path = require("path");
var util = require("util")
var path = require("path");
var colors = require("colors");
var exec = require('child_process').exec;

function strEndsWith(str, suffix) {
  return str.match(suffix + "$") == suffix;
}

function info(str) {
  console.log("[" + "INFO".green + "] " + str);
};

function warn(str) {
  console.log("[" + "WARN".yellow + "] " + str);
};

function error(str) {
  console.log("[" + "ERROR".red + "] " + str);
};

function genSymLinks() {
  function _gemSymLinks(f) {
    fs.stat(f, function(err, stats) {
      if (err != null) {
        throw err;
      }
      else {
        if (stats.isDirectory()) {
          fs.readdir(f, function(err, files) {
            if (err != null) {
              throw err;
            }
            else {
              files.forEach(function(file) {
                _gemSymLinks(path.join(f, file));
              });
            }
          });
        }
        else {
          if (strEndsWith(f, ".el")) {
            exec(changeDirectory("emacs.d")
                 + "ln -sf " + path.relative(path.join(__dirname, "emacs.d"), f)
                 + " .");
            console.log("f: " + f);
          }
        }
      }
    });
  };
    _gemSymLinks(path.join(__dirname, "modules"));
    _gemSymLinks(path.join(__dirname, "elisps"));
};

function changeDirectory(subdir) {
  if (subdir)
    return "cd " + path.join(__dirname, subdir) + " && ";
  else
    return "cd " + __dirname + " && ";
}

function submodules(cb) {
  fs.readdir(path.join(__dirname, "modules"), function(err, files) {
    if (err != null) {
      throw err;
    }
    else {
      cb(files);
    }
  });
};

function submodulesMain() {
  submodules(function(modules) {
    console.log(modules.join("\n"));
  });
};

function updateMain() {
  info("updating git-your-emacs");
  exec(changeDirectory() + "git pull", function(err, stdout) {
    if (err != null)
      throw new Error("cannot update git");
    else {
      submodules(function(modules) {
        modules.forEach(function(m) {
          info("updating " + m);
          exec("cd " + path.join(__dirname, m) + " && git pull", function(err, stdout) {
            if (err != null) {
              throw err;
            }
            else {
              genSymLinks();
              info("done updating " + m);
            }
          });
        });
      });
    }
  });
};

function emacsInitMain() {
  console.log("\n\
;; auto-generated by git-your-emacs\n\
(add-to-list 'load-path \"" + __dirname + "./emacs.d\")\n\
");
};

function addModuleMain() {
  var submodule = ARGV._[1];
  info("adding " + submodule);
  exec(changeDirectory("modules") + "git clone " + submodule, function(err, stdout) {
    if (err != null) {
      throw err;
    }
    else {
      genSymLinks();
      info("done");
    }
  });
};

function removeModuleMain() {
  var submodule = ARGV._[1];
  info("removing " + submodule);
  submodules(function(modules) {
    if(modules.indexOf(submodule) != -1) {
      exec("rm -rf " + path.join(__dirname, "modules", submodule), function(err, stdout) {
        if (err != null) {
          throw err;
        }
        else {
          genSymLinks();
          info("done");
        }
      });
    }
    else {
      warn(("no such submodule: " + submodule));
    }
  });
};

var COMMANDS = {
  "update": {
    callback: updateMain,
    description: "update all submodules"
  },
  "emacs-init": {
    callback: emacsInitMain,
    description: "generate emacs lisp to load emacs files"
  },
  "add-module": {
    callback: addModuleMain,
    description: "add a new git submodule to git-your-emacs"
  },
  "submodules": {
    callback: submodulesMain,
    description: "list submodules"
  },
  "remove-module": {
    callback: removeModuleMain,
    description: "remove a module"
  }
};

function main() {
  try {
    if (ARGV._.length == 0) {
      throw new Error("no command is specified");
    }
    else {
      if (!path.existsSync(__dirname, "modules"))
        fs.mkdirSync(path.join(__dirname, "modules"));
      var command = ARGV._[0];
      for (var key in COMMANDS) {
        if (command == key) {
          COMMANDS[key].callback();
          return;
        }
      }
      throw new Error(command + " is not supported");
    }
  }
  catch (e) {
    error(e.toString().red);
    console.log(optimist.help());
  }
};

// arguments
var optimist = require("optimist");
(function() {
  var command_usage = "Usage: $0 command [options]";
  for (var key in COMMANDS) {
    command_usage += "\n  " + key + ": " + COMMANDS[key].description;
  }
  optimist.usage(command_usage);
})();
var ARGV = optimist.argv;
main();
